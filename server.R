BsaTGGT <- "CTGGTCTCGTGGT"
BsaSTOPCTTG <- "TAACTTGAGAGACCTG"
BsaMid2 <- "AGAGACCTG"
BsaMid1 <- "CTGGTCTCG"
BBseq1 <- "ATGCCATAGCATTTTTATCCATAAGATTAGCGGATCCTACCTGACGCTTTTTATCGCAACTCTCTACTGTTTCTCCATACCCGTTTTTTGGGCTAACAGGAGGAATTAACCATGGGCAGCAGCCATCATCATCATCATCACGGCAGCGGCCTGGTGCCGCGCGGCAGCGCTGGT"
BBseq2 <- "CTTGGGCCCGAACAAAAACTCATCTCAGAAGAGGATCTGAATAGCGCCGTCGACCATCATCATCATCATCATTGAGTTTAAACGGACTCCAGCTTGGCTGTTTTGGCGGATGAGAGAAGATTTTCAGCCTGATACAGATTAAATCAGAACGCAGAAGCGGTCTGATAAAACAGAATTTGCCTGGCGGCAGTAGCGCGGTGGTCCCACCTGACCCCATGCCGAACTCAGAAGTGAAACGCCGTAGCGCCGATGGTAGTGTGGGGTGTCCCCATGCGAGAGTAGGGAACTGCCAGGCATCAAATAAAACGAAAGGCTCAGTCGAAAGACTGGGCCTTTCGTTTTATCTGTTGTTTGTCGGTGAACGCTCTCCTGAGTAGGACAAATCCGCCGGGAGCGGATTTGAACGTTGCGAAGCAACGGCCCGGAGGGTGGCGGGCAGGACGCCCGCCATAAACTGCCAGGCATCAAATTAAGCAGAAGGCCATCCTGACGGATGGCCTTTTTGCGTTTCTACAAACTCTTTTTGTTTATTTTTCTAAATACATTCAAATATGTATCCGCTCATGAGACAATAACCCTGATAAATGCTTCAATAATATTGAAAAAGGAAGAGTATGAGTATTCAACATTTCCGTGTCGCCCTTATTCCCTTTTTTGCGGCATTTTGCCTTCCTGTTTTTGCTCACCCAGAAACGCTGGTGAAAGTAAAAGATGCTGAAGATCAGTTGGGTGCACGAGTGGGTTACATCGAACTGGATCTCAACAGCGGTAAGATCCTTGAGAGTTTTCGCCCCGAAGAACGTTTTCCAATGATGAGCACTTTTAAAGTTCTGCTATGTGGCGCGGTATTATCCCGTGTTGACGCCGGGCAAGAGCAACTCGGTCGCCGCATACACTATTCTCAGAATGACTTGGTTGAGTACTCACCAGTCACAGAAAAGCATCTTACGGATGGCATGACAGTAAGAGAATTATGCAGTGCTGCCATAACCATGAGTGATAACACTGCGGCCAACTTACTTCTGACAACGATCGGAGGACCGAAGGAGCTAACCGCTTTTTTGCACAACATGGGGGATCATGTAACTCGCCTTGATCGTTGGGAACCGGAGCTGAATGAAGCCATACCAAACGACGAGCGTGACACCACGATGCCTGTAGCAATGGCAACAACGTTGCGCAAACTATTAACTGGCGAACTACTTACTCTAGCTTCCCGGCAACAATTAATAGACTGGATGGAGGCGGATAAAGTTGCAGGACCACTTCTGCGCTCGGCCCTTCCGGCTGGCTGGTTTATTGCTGATAAATCTGGAGCCGGTGAGCGTGGGAGTCGCGGTATCATTGCAGCACTGGGGCCAGATGGTAAGCCCTCCCGTATCGTAGTTATCTACACGACGGGGAGTCAGGCAACTATGGATGAACGAAATAGACAGATCGCTGAGATAGGTGCCTCACTGATTAAGCATTGGTAACTGTCAGACCAAGTTTACTCATATATACTTTAGATTGATTTAAAACTTCATTTTTAATTTAAAAGGATCTAGGTGAAGATCCTTTTTGATAATCTCATGACCAAAATCCCTTAACGTGAGTTTTCGTTCCACTGAGCGTCAGACCCCGTAGAAAAGATCAAAGGATCTTCTTGAGATCCTTTTTTTCTGCGCGTAATCTGCTGCTTGCAAACAAAAAAACCACCGCTACCAGCGGTGGTTTGTTTGCCGGATCAAGAGCTACCAACTCTTTTTCCGAAGGTAACTGGCTTCAGCAGAGCGCAGATACCAAATACTGTCCTTCTAGTGTAGCCGTAGTTAGGCCACCACTTCAAGAACTCTGTAGCACCGCCTACATACCTCGCTCTGCTAATCCTGTTACCAGTGGCTGCTGCCAGTGGCGATAAGTCGTGTCTTACCGGGTTGGACTCAAGACGATAGTTACCGGATAAGGCGCAGCGGTCGGGCTGAACGGGGGGTTCGTGCACACAGCCCAGCTTGGAGCGAACGACCTACACCGAACTGAGATACCTACAGCGTGAGCTATGAGAAAGCGCCACGCTTCCCGAAGGGAGAAAGGCGGACAGGTATCCGGTAAGCGGCAGGGTCGGAACAGGAGAGCGCACGAGGGAGCTTCCAGGGGGAAACGCCTGGTATCTTTATAGTCCTGTCGGGTTTCGCCACCTCTGACTTGAGCGTCGATTTTTGTGATGCTCGTCAGGGGGGCGGAGCCTATGGAAAAACGCCAGCAACGCGGCCTTTTTACGGTTCCTGGCCTTTTGCTGGCCTTTTGCTCACATGTTCTTTCCTGCGTTATCCCCTGATTCTGTGGATAACCGTATTACCGCCTTTGAGTGAGCTGATACCGCTCGCCGCAGCCGAACGACCGAGCGCAGCGAGTCAGTGAGCGAGGAAGCGGAAGAGCGCCTGATGCGGTATTTTCTCCTTACGCATCTGTGCGGTATTTCACACCGCATATCGTGCACTCTCAGTACAATCTGCTCTGATGCCGCATAGTTAAGCCAGTATACACTCCGCTATCGCTACGTGACTGGGTCATGGCTGCGCCCCGACACCCGCCAACACCCGCTGACGCGCCCTGACGGGCTTGTCTGCTCCCGGCATCCGCTTACAGACAAGCTGTGACCGTCTCCGGGAGCTGCATGTGTCAGAGGTTTTCACCGTCATCACCGAAACGCGCGAGGCAGCAGATCAATTCGCGCGCGAAGGCGAAGCGGCATGCATAATGTGCCTGTCAAATGGACGAAGCAGGGATTCTGCAAACCCTATGCTACTCCGTCAAGCCGTCAATTGTCTGATTCGTTACCAATTATGACAACTTGACGGCTACATCATTCACTTTTTCTTCACAACCGGCACGGAACTCGCTCGGGCTGGCCCCGGTGCATTTTTTAAATACCCGCGAGAAATAGAGTTGATCGTCAAAACCAACATTGCGACCGACGGTGGCGATAGGCATCCGGGTGGTGCTCAAAAGCAGCTTCGCCTGGCTGATACGTTGGTCCTCGCGCCAGCTTAAGACGCTAATCCCTAACTGCTGGCGGAAAAGATGTGACAGACGCGACGGCGACAAGCAAACATGCTGTGCGACGCTGGCGATATCAAAATTGCTGTCTGCCAGGTGATCGCTGATGTACTGACAAGCCTCGCGTACCCGATTATCCATCGGTGGATGGAGCGACTCGTTAATCGCTTCCATGCGCCGCAGTAACAATTGCTCAAGCAGATTTATCGCCAGCAGCTCCGAATAGCGCCCTTCCCCTTGCCCGGCGTTAATGATTTGCCCAAACAGGTCGCTGAAATGCGGCTGGTGCGCTTCATCCGGGCGAAAGAACCCCGTATTGGCAAATATTGACGGCCAGTTAAGCCATTCATGCCAGTAGGCGCGCGGACGAAAGTAAACCCACTGGTGATACCATTCGCGAGCCTCCGGATGACGACCGTAGTGATGAATCTCTCCTGGCGGGAACAGCAAAATATCACCCGGTCGGCAAACAAATTCTCGTCCCTGATTTTTCACCACCCCCTGACCGCGAATGGTGAGATTGAGAATATAACCTTTCATTCCCAGCGGTCGGTCGATAAAAAAATCGAGATAACCGTTGGCCTCAATCGGCGTTAAACCCGCCACCAGATGGGCATTAAACGAGTATCCCGGCAGCAGGGGATCATTTTGCGCTTCAGCCATACTTTTCATACTCCCGCCATTCAGAGAAGAAACCAATTGTCCATATTGCATCAGACATTGCCGTCACTGCGTCTTTTACTGGCTCTTCTCGCTAACCAAACCGGTAACCCCGCTTATTAAAAGCATTCTGTAACAAAGCGGGACCAAAGCCATGACAAAAACGCGTAACAAAAGTGTCTATAATCACGGCAGAAAAGTCCACATTGATTATTTGCACGGCGTCACACTTTGCT"
sumoBB1 <- "ATGCCATAGCATTTTTATCCATAAGATTAGCGGATCCTACCTGACGCTTTTTATCGCAACTCTCTACTGTTTCTCCATACCCGTTTTTTGGGCTAACAGGAGGAATTAACCATGGGCAGCAGCCATCATCATCATCATCACGGCAGCGGCCTGGTGCCGCGCGGCAGCGCTAGCATGTCGGACTCAGAAGTCAATCAAGAAGCTAAGCCAGAGGTCAAGCCAGAAGTCAAGCCTGAGACTCACATCAATTTAAAGGTGTCCGATGGATCTTCAGAGATCTTCTTCAAGATCAAAAAGACCACTCCTTTAAGAAGGCTGATGGAAGCGTTCGCTAAAAGACAGGGTAAGGAAATGGACTCCTTAAGATTCTTGTACGACGGTATTAGAATTCAAGCTGATCAGACCCCTGAAGATTTGGACATGGAGGATAACGATATTATTGAGGCTCACAGAGAACAGATTGGTGGT"
sumoBB2 <-"GGCCCGAACAAAAACTCATCTCAGAAGAGGATCTGAATAGCGCCGTCGACCATCATCATCATCATCATTGAGTTTAAACGGACTCCAGCTTGGCTGTTTTGGCGGATGAGAGAAGATTTTCAGCCTGATACAGATTAAATCAGAACGCAGAAGCGGTCTGATAAAACAGAATTTGCCTGGCGGCAGTAGCGCGGTGGTCCCACCTGACCCCATGCCGAACTCAGAAGTGAAACGCCGTAGCGCCGATGGTAGTGTGGGGTGTCCCCATGCGAGAGTAGGGAACTGCCAGGCATCAAATAAAACGAAAGGCTCAGTCGAAAGACTGGGCCTTTCGTTTTATCTGTTGTTTGTCGGTGAACGCTCTCCTGAGTAGGACAAATCCGCCGGGAGCGGATTTGAACGTTGCGAAGCAACGGCCCGGAGGGTGGCGGGCAGGACGCCCGCCATAAACTGCCAGGCATCAAATTAAGCAGAAGGCCATCCTGACGGATGGCCTTTTTGCGTTTCTACAAACTCTTTTTGTTTATTTTTCTAAATACATTCAAATATGTATCCGCTCATGAGACAATAACCCTGATAAATGCTTCAATAATATTGAAAAAGGAAGAGTATGAGTATTCAACATTTCCGTGTCGCCCTTATTCCCTTTTTTGCGGCATTTTGCCTTCCTGTTTTTGCTCACCCAGAAACGCTGGTGAAAGTAAAAGATGCTGAAGATCAGTTGGGTGCACGAGTGGGTTACATCGAACTGGATCTCAACAGCGGTAAGATCCTTGAGAGTTTTCGCCCCGAAGAACGTTTTCCAATGATGAGCACTTTTAAAGTTCTGCTATGTGGCGCGGTATTATCCCGTGTTGACGCCGGGCAAGAGCAACTCGGTCGCCGCATACACTATTCTCAGAATGACTTGGTTGAGTACTCACCAGTCACAGAAAAGCATCTTACGGATGGCATGACAGTAAGAGAATTATGCAGTGCTGCCATAACCATGAGTGATAACACTGCGGCCAACTTACTTCTGACAACGATCGGAGGACCGAAGGAGCTAACCGCTTTTTTGCACAACATGGGGGATCATGTAACTCGCCTTGATCGTTGGGAACCGGAGCTGAATGAAGCCATACCAAACGACGAGCGTGACACCACGATGCCTGTAGCAATGGCAACAACGTTGCGCAAACTATTAACTGGCGAACTACTTACTCTAGCTTCCCGGCAACAATTAATAGACTGGATGGAGGCGGATAAAGTTGCAGGACCACTTCTGCGCTCGGCCCTTCCGGCTGGCTGGTTTATTGCTGATAAATCTGGAGCCGGTGAGCGTGGGAGTCGCGGTATCATTGCAGCACTGGGGCCAGATGGTAAGCCCTCCCGTATCGTAGTTATCTACACGACGGGGAGTCAGGCAACTATGGATGAACGAAATAGACAGATCGCTGAGATAGGTGCCTCACTGATTAAGCATTGGTAACTGTCAGACCAAGTTTACTCATATATACTTTAGATTGATTTAAAACTTCATTTTTAATTTAAAAGGATCTAGGTGAAGATCCTTTTTGATAATCTCATGACCAAAATCCCTTAACGTGAGTTTTCGTTCCACTGAGCGTCAGACCCCGTAGAAAAGATCAAAGGATCTTCTTGAGATCCTTTTTTTCTGCGCGTAATCTGCTGCTTGCAAACAAAAAAACCACCGCTACCAGCGGTGGTTTGTTTGCCGGATCAAGAGCTACCAACTCTTTTTCCGAAGGTAACTGGCTTCAGCAGAGCGCAGATACCAAATACTGTCCTTCTAGTGTAGCCGTAGTTAGGCCACCACTTCAAGAACTCTGTAGCACCGCCTACATACCTCGCTCTGCTAATCCTGTTACCAGTGGCTGCTGCCAGTGGCGATAAGTCGTGTCTTACCGGGTTGGACTCAAGACGATAGTTACCGGATAAGGCGCAGCGGTCGGGCTGAACGGGGGGTTCGTGCACACAGCCCAGCTTGGAGCGAACGACCTACACCGAACTGAGATACCTACAGCGTGAGCTATGAGAAAGCGCCACGCTTCCCGAAGGGAGAAAGGCGGACAGGTATCCGGTAAGCGGCAGGGTCGGAACAGGAGAGCGCACGAGGGAGCTTCCAGGGGGAAACGCCTGGTATCTTTATAGTCCTGTCGGGTTTCGCCACCTCTGACTTGAGCGTCGATTTTTGTGATGCTCGTCAGGGGGGCGGAGCCTATGGAAAAACGCCAGCAACGCGGCCTTTTTACGGTTCCTGGCCTTTTGCTGGCCTTTTGCTCACATGTTCTTTCCTGCGTTATCCCCTGATTCTGTGGATAACCGTATTACCGCCTTTGAGTGAGCTGATACCGCTCGCCGCAGCCGAACGACCGAGCGCAGCGAGTCAGTGAGCGAGGAAGCGGAAGAGCGCCTGATGCGGTATTTTCTCCTTACGCATCTGTGCGGTATTTCACACCGCATATCGTGCACTCTCAGTACAATCTGCTCTGATGCCGCATAGTTAAGCCAGTATACACTCCGCTATCGCTACGTGACTGGGTCATGGCTGCGCCCCGACACCCGCCAACACCCGCTGACGCGCCCTGACGGGCTTGTCTGCTCCCGGCATCCGCTTACAGACAAGCTGTGACCGTCTCCGGGAGCTGCATGTGTCAGAGGTTTTCACCGTCATCACCGAAACGCGCGAGGCAGCAGATCAATTCGCGCGCGAAGGCGAAGCGGCATGCATAATGTGCCTGTCAAATGGACGAAGCAGGGATTCTGCAAACCCTATGCTACTCCGTCAAGCCGTCAATTGTCTGATTCGTTACCAATTATGACAACTTGACGGCTACATCATTCACTTTTTCTTCACAACCGGCACGGAACTCGCTCGGGCTGGCCCCGGTGCATTTTTTAAATACCCGCGAGAAATAGAGTTGATCGTCAAAACCAACATTGCGACCGACGGTGGCGATAGGCATCCGGGTGGTGCTCAAAAGCAGCTTCGCCTGGCTGATACGTTGGTCCTCGCGCCAGCTTAAGACGCTAATCCCTAACTGCTGGCGGAAAAGATGTGACAGACGCGACGGCGACAAGCAAACATGCTGTGCGACGCTGGCGATATCAAAATTGCTGTCTGCCAGGTGATCGCTGATGTACTGACAAGCCTCGCGTACCCGATTATCCATCGGTGGATGGAGCGACTCGTTAATCGCTTCCATGCGCCGCAGTAACAATTGCTCAAGCAGATTTATCGCCAGCAGCTCCGAATAGCGCCCTTCCCCTTGCCCGGCGTTAATGATTTGCCCAAACAGGTCGCTGAAATGCGGCTGGTGCGCTTCATCCGGGCGAAAGAACCCCGTATTGGCAAATATTGACGGCCAGTTAAGCCATTCATGCCAGTAGGCGCGCGGACGAAAGTAAACCCACTGGTGATACCATTCGCGAGCCTCCGGATGACGACCGTAGTGATGAATCTCTCCTGGCGGGAACAGCAAAATATCACCCGGTCGGCAAACAAATTCTCGTCCCTGATTTTTCACCACCCCCTGACCGCGAATGGTGAGATTGAGAATATAACCTTTCATTCCCAGCGGTCGGTCGATAAAAAAATCGAGATAACCGTTGGCCTCAATCGGCGTTAAACCCGCCACCAGATGGGCATTAAACGAGTATCCCGGCAGCAGGGGATCATTTTGCGCTTCAGCCATACTTTTCATACTCCCGCCATTCAGAGAAGAAACCAATTGTCCATATTGCATCAGACATTGCCGTCACTGCGTCTTTTACTGGCTCTTCTCGCTAACCAAACCGGTAACCCCGCTTATTAAAAGCATTCTGTAACAAAGCGGGACCAAAGCCATGACAAAAACGCGTAACAAAAGTGTCTATAATCACGGCAGAAAAGTCCACATTGATTATTTGCACGGCGTCACACTTTGCT"


# # function to make a random DNA sequence of length n, for testing
# example_seq <- function(n) {
#   sample(c('A', 'C', 'T', 'G'), n, replace = TRUE) %>% paste0(collapse = '')
# }


# Function to parse FASTA format and create a data frame
parse_fasta <- function(input_text) {
  # Initialize empty vectors to store sequence names and sequences
  seq_names <- character(0)
  seq_data <- character(0)
  
  # Split the input text into lines
  lines <- unlist(strsplit(input_text, "\n"))
  seq_names <- lines[str_detect(lines, "^>")]
  seq_data <- lines[!str_detect(lines, "^>")] 
  
  if (length(seq_names) != length(seq_data)) {
    print("problem with sequence")
    return()
  }
  
  
  # Create a data frame from the vectors
  fasta_df <- data.frame(Name = seq_names, Sequence = seq_data)
  # Create a list from the vectors
  fasta_list <- as.list(seq_data)
  names(fasta_list) <- seq_names

  return(list(fasta_list, fasta_df))
}

###

# # func. to find bsai sites in input seq, returns a dataframe
# bsai_locate <- function(seq) {
#   df <- rbind(
#     seq %>% str_locate_all(., "GGTCTC") %>% as.data.frame() %>% mutate(dir = 'fw'),
#     seq %>% str_locate_all(., "GAGACC") %>% as.data.frame() %>% mutate(dir = 'rv')
#   ) %>% mutate(cod_pos = ((start + 2) %%3) + 1)
#   df[order(df$start),] # return in order of where site was encountered
#   
#   # Create a new data frame with updated row numbers
#   df <- data.frame(RowNumber = 1:nrow(df), df)
#   
#   # Remove the 'RowNumber' column
#   df <- subset(df, select = -RowNumber)
# }

### Modify bsai_locate function so it uses values of  list as input

bsai_locate <- function(seq) {
  fw_matches <- str_locate_all(seq, "GGTCTC")[[1]]
  rv_matches <- str_locate_all(seq, "GAGACC")[[1]]
  
  if (is.null(fw_matches) && is.null(rv_matches)) {
    # If no matches were found, create a row with NA values
    combined_df <- data.frame(start = NA, end = NA, dir = NA, cod_pos = NA, seq_name = "Seq")
  } else {
    if (length(fw_matches) == 0) {
      fw_df <- data.frame(start = NA, end = NA, dir = 'fw')
    } else {
      fw_df <- data.frame(start = fw_matches[, 1], end = fw_matches[, 2], dir = 'fw')
    }
    
    if (length(rv_matches) == 0) {
      rv_df <- data.frame(start = NA, end = NA, dir = 'rv')
    } else {
      rv_df <- data.frame(start = rv_matches[, 1], end = rv_matches[, 2], dir = 'rv')
    }
    
    combined_df <- bind_rows(fw_df, rv_df) %>%
      mutate(cod_pos = ifelse(!is.na(start), ((start + 2) %% 3) + 1, NA),
             seq_name = "Seq")
  }
  
  combined_df <- combined_df[order(combined_df$start), ]
  
  combined_df <- combined_df[!is.na(combined_df$start),]
  return(combined_df)
}


# Use lapply to apply the bsai_locate function to each sequence in the list
#result_list <- lapply(fasta_df$seq_data, bsai_locate)

# Print the resulting list of data frames
#print(result_list)
###

# func. to determine how many fragments are required given a sequence and a max. frag. length
calc_fragments <- function(seq, max_len) {
  ceiling(nchar(seq) / max_len) # ceiling() rounds up to next integer
}

# function to calculate the break points in a sequence, given max. frag. length
calc_break_points <- function(seq, max_len) {
  (calc_fragments(seq, max_len) -1) * 2
}

# func. to create n_chunks sequence fragments, returns vector of strings
seq_chunks <- function(seq, n_chunks) {
  if (n_chunks == 1) { return(seq) } # if only 1 chunk is requested, return input and stop
  seq <- str_split(seq, '')[[1]] # create vector from string
  split(seq, cut(seq_along(seq), n_chunks, labels = FALSE)) # returns list where each item is vector chunk
}

# func. to create df with seq. fragments, given sequence and max. frag. length
split_seq_in_chunks <- function(seq, max_len) {
  if (seq == '' || !is.numeric(max_len) || is.na(max_len)) { return(data.frame()) } 
  chunks <- seq_chunks(seq = seq, n_chunks = calc_fragments(seq, max_len)) %>% lapply(., function(x) paste(x, collapse = '')) 
  data.frame(length = lapply(chunks, function(x) str_length(x)) %>% unlist(), 
             fragments = unlist(chunks)) # convert list into data frame, can add more info (columns) about fragments
} 


server <- function(input, output, session) {
  
  # accept multiple fasta sequences
  parsed_data <- reactive({
    input_text <- input$fasta_input
    parse_fasta(input_text)
  })
  
  output$fasta_table <- renderTable({
    parsed_data()[[2]]
  })
  
  # for testing; create random sequences of length specified in input$ex_len
  # observeEvent(input$ex_len, {
  #   if (str_detect(input$ex_len, '^[0-9]+$')) {
  #     updateTextInput(session = getDefaultReactiveDomain(),
  #                     inputId = 'sequence',
  #                     value = example_seq(n = as.numeric(input$ex_len)))
  #   }
  # }, ignoreInit = TRUE)
  
  # process the sequence: upper case, detect bsai sites, find position within codon, suggest swapped codon
  
  bsai_table <- function(seq) {
    df <- bsai_locate(seq = toupper(seq))
    df$first_cod_to_change <- ifelse(df$dir == 'fw',
                                     c('GTC', 'GGT', 'TCT')[(df$cod_pos %% 3) + 1],
                                     c('AGA', 'GAG', 'GAC')[(df$cod_pos %% 3) + 1])
    df$change_cod_to <- ifelse(df$dir == 'fw',
                               c('GTG', 'GGC', 'TCC')[(df$cod_pos %% 3) + 1],
                               c('AGG', 'GAA', 'GAT')[(df$cod_pos %% 3) + 1])
    
    # Create a new column with the position on the sequence where the codon that has to be changed starts.

    for (i in seq_len(nrow(df))) {
      if (df$cod_pos[i] == 3)
        df$calc_pos[i] <- df$start[i] + 1
      
      if (df$cod_pos[i] == 2)
        df$calc_pos[i] <- df$start[i] + 2
      
      if (df$cod_pos[i] == 1)
        df$calc_pos[i] <- df$start[i]
    }
    df
  }
  
  modified_seq <- function(df, seq) {
    # Replace codons in the input sequence
    modified_sequence <- seq
    for (i in seq_len(nrow(df))) {
      start_pos <- df[i, "start"]
      end_pos <- df[i, "end"]
      replacement <- df[i, "change_cod_to"]
      pos_in_seq <- df[i, "calc_pos"]
      
      modified_sequence <- paste0(substring(modified_sequence, 1, pos_in_seq - 1),
                                  replacement,
                                  substring(modified_sequence, pos_in_seq + 3))
    }
    modified_sequence
  }
  
  processed_input <- reactive({
    seq_list <- parsed_data()[[1]]
    list_bsai_dfs <- lapply(seq_list, function(x) {
      df <- bsai_table(x)
      modified_sequence <- modified_seq(df, x)
      list(df, modified_sequence)
      
    })
    
    seqs <- lapply(list_bsai_dfs, function(x) x[[2]])
    
    fasta_out <-
      c(rbind(names(seqs), as.character(unlist(seqs)))) %>% paste(collapse = '\n')
    updateTextInput(session = getDefaultReactiveDomain(),
                                      inputId = 'mod_seq',
                                      value = fasta_out)
    
    list_bsai_dfs
    })

  observe(processed_input())
  
  # output table for bsai sites
  # filling a new text input field with the new sequence
  # output$bsai_table <- renderDT({
  #   updateTextInput(session = getDefaultReactiveDomain(),
  #                   inputId = 'mod_seq',
  #                   value = processed_input())
  #  datatable(processed_input()[[1]], options = list(dom = 't'))  # option removes (here) pointless search field
  # })

  
  # # output table for fragments
  # output$frag_table <- renderDT({
  #   fragm.df <- split_seq_in_chunks(seq = input$mod_seq, max_len = as.numeric(input$frag_len))
  #   fragm.df$p5_Bsa <- BsaMid1
  #   fragm.df$p3_Bsa <- BsaMid2
  #   fragm.df[1, "p5_Bsa"] <- BsaTGGT
  #   fragm.df[nrow(fragm.df), "p3_Bsa"] <- BsaSTOPCTTG  
  #   fragm.df$p5_overhang <- substr(fragm.df$fragments, 1, 4)
  #   #fragm.df$p3_overhang <- substr(fragm.df$fragments, nchar(fragm.df$fragments) - 3, nchar(fragm.df$fragments))
  #   print(fragm.df[, "p5_overhang"])
  #   ### checks overhangs  
  #     #1# are all overhangs unique?
  #   
  #       # Find duplicated values and report row numbers
  #   
  #   # Define the columns you want to compare for uniqueness
  #   column1_to_check <- fragm.df$p5_overhang
  #   column2_to_check <- fragm.df$p3_overhang
  #   
  #   # Combine both columns into a single vector for comparison
  #   combined_column <- c(column1_to_check, column2_to_check)
  #   
  #   # Find duplicated values and report row numbers
  #   duplicated_rows <- which(duplicated(column1_to_check) | duplicated(column1_to_check, fromLast = TRUE))
  #   
  #   # Check if there are any duplicated values
  #   if (length(duplicated_rows) > 0) {
  #     cat("Duplicate values found in the following rows:\n")
  #     for (row_num in duplicated_rows) {
  #       cat("Row", row_num, ":", combined_column[row_num], "\n")
  #       fragm.df$p5_overhang_check_unique[i] <- FALSE
  #     }
  #   } else {
  #     cat("No duplicate values found between the two columns.\n")
  #     fragm.df$p5_overhang_check_unique <- TRUE
  #     
  #   }
  #   
  #     #2# is any overhang palindromic?
  # 
  #   # Function to check if a DNAString is palindromic
  #   is_palindromic <- function(sequence) {
  #     complement_sequence <- reverseComplement(DNAString(sequence))
  #     identical(sequence, as.character(complement_sequence))
  #   }
  #   
  #   # Check if each sequence in the 'Sequence' column is palindromic
  #   fragm.df$p5_overhang_check_palindrome <- sapply(fragm.df$p5_overhang, function(seq) !is_palindromic(seq))
  #   
  # 
  #     #3# does any overhang have more than 2 repeats?   
  #  
  #   # Function to check for repeated characters more than twice
  #   has_repeated_characters <- function(text) {
  #     any(rle(strsplit(text, "")[[1]])$lengths > 2)
  #   }
  #   # Check if each value in the 'Text' column has repeated characters more than twice
  #   fragm.df$p5_overhang_check_repeats <- sapply(fragm.df$p5_overhang, has_repeated_characters)
  #   
  #   # Invert the 'repeat' column, so it's TRUE for rows with repeats and FALSE for others
  #   fragm.df$p5_overhang_check_repeats <- !fragm.df$p5_overhang_check_repeats
  # 
  #   #4# pass all checks?
  #   
  #   # Create a new column 'test' based on the conditions
  #   fragm.df$test <- ifelse(fragm.df$p5_overhang_check_unique & fragm.df$p5_overhang_check_palindrome & fragm.df$p5_overhang_check_repeats, TRUE, FALSE)
  #   
  #   ### this only if all checks are true, otherwise change fragments
  #   # Create another data frame by pasting values from fragm.df
  #   
  #   full_fragm.df <- data.frame(full_fragm = NA)
  #   
  #   #full_fragm.df$full_fragm <- ifelse(fragm.df$test, paste(fragm.df$p5_Bsa, fragm.df$p5_overhang, fragm.df$fragments, fragm.df$p3_Bsa), xxxxxxxxxxx)
  # print(full_fragm.df)  
  # fragm.df
  # #list(fragm.df, full_fragm.df)
  # })
  # 
  # return some info about fragments as text
  output$total_len <- renderText({
    frag_input_seq <- input$mod_seq
    mid_sites_to_add <- calc_break_points(seq = frag_input_seq, max_len = as.numeric(input$frag_len))
    total_len <- nchar(frag_input_seq) + nchar(BsaTGGT) + nchar(BsaSTOPCTTG) + (mid_sites_to_add * nchar(BsaMid1))
    HTML(paste0("Input sequence length: &nbsp", as.character(nchar(frag_input_seq)), "<br>", 
                "Number of fragments &nbsp: &nbsp", as.character(ceiling(nchar(frag_input_seq)/(max_len = as.numeric(input$frag_len)))), "<br>",
                "Final number of bases: &nbsp", as.character(total_len)))
  })
  
  # add BsaI sites at the beginning and end of the fragments
  
    # # Check length of sequence
    # length_seq <- nchar(seq)
    # 
    # # Number of fragments needed: 1 (0-288), 2 (291-580), 3 (581-870), 4 (871-1160), 5 (1161-1450)
    # if (length_seq <= 288*3) {
    #   fragments <- cat(BsaTGGT, seq, BsaSTOPCTTG, sep = "")
    # 
    # } else if (length_seq <= 580*3){
    #   piece1 <- substr(seq, 1, nchar(seq)/2)
    #   fragm1 <- cat(BsaTGGT, piece1, BsaMid1, sep = "")
    # 
    #   piece2 <- substr(seq, (nchar(seq)/2)+1, nchar(seq))
    #   fragm2 <- cat(BsaMid2, piece2, BsaSTOPCTTG, sep = "")
    # 
    #   fragments <- c(fragm1, fragm2)
    # 
    # } else if (length_seq <= 870*3){
    #   piece1 <- substr(seq, 1, nchar(seq)/3)
    #   fragm1 <- cat(BsaTGGT, piece1, BsaMid1, sep = "")
    # 
    #   piece2 <- substr(seq, (nchar(seq)/3)+1, nchar(seq)/3*2)
    #   fragm2 <- cat(BsaMid2, piece2, BsaMid1, sep = "")
    # 
    #   piece3 <- substr(seq, (nchar(seq)/3*2)+1, nchar(seq))
    #   fragm3 <- cat(BsaMid2, piece3, BsaSTOPCTTG, sep = "")
    # 
    #   fragments <- c(fragm1, fragm2, fragm3)
    # 
    # } else if (length_seq <= 1160*3){
    #   piece1 <- substr(seq, 1, nchar(seq)/4)
    #   fragm1 <- cat(BsaTGGT, piece1, BsaMid1, sep = "")
    # 
    #   piece2 <- substr(seq, (nchar(seq)/4)+1, nchar(seq)/4*2)
    #   fragm2 <- cat(BsaMid2, piece2, BsaMid1, sep = "")
    # 
    #   piece3 <- substr(seq, (nchar(seq)/4*2)+1, nchar(seq)/4*3)
    #   fragm3 <- cat(BsaMid2, piece3, BsaMid1, sep = "")
    # 
    #   piece4 <- substr(seq, (nchar(seq)/4*3)+1, nchar(seq))
    #   fragm4 <- cat(BsaMid2, piece4, BsaSTOPCTTG, sep = "")
    # 
    #   fragments <- c(fragm1, fragm2, fragm3, fragm4)
    # 
    # } else if (length_seq <= 1450*3){
    #   piece1 <- substr(seq, 1, nchar(seq)/5)
    #   fragm1 <- cat(BsaTGGT, piece1, BsaMid1, sep = "")
    # 
    #   piece2 <- substr(seq, (nchar(seq)/5)+1, nchar(seq)/5*2)
    #   fragm2 <- cat(BsaMid2, piece2, BsaMid1, sep = "")
    # 
    #   piece3 <- substr(seq, (nchar(seq)/5*2)+1, nchar(seq)/5*3)
    #   fragm3 <- cat(BsaMid2, piece3, BsaMid1, sep = "")
    # 
    #   piece4 <- substr(seq, (nchar(seq)/5*3)+1, nchar(seq)/5*4)
    #   fragm4 <- cat(BsaMid2, piece4, BsaMid1, sep = "")
    # 
    #   piece5 <- substr(seq, (nchar(seq)/5*4)+1, nchar(seq))
    #   fragm5 <- cat(BsaMid2, piece5, BsaSTOPCTTG, sep = "")
    # 
    #   fragments <- c(fragm1, fragm2, fragm3, fragm4, fragm5)
    # 
    # } else {
    # #this should be a text output
    #   return("Sequence too long")
    # }
  
  
}

