BsaTGGT <- "CTGGTCTCGTGGT"
BsaSTOPCTTG <- "TAACTTGAGAGACCTG"
BsaMid1 <- "AGAGACCTG"
BsaMid2 <- "CTGGTCTCG"
BBseq1 <- "ATGCCATAGCATTTTTATCCATAAGATTAGCGGATCCTACCTGACGCTTTTTATCGCAACTCTCTACTGTTTCTCCATACCCGTTTTTTGGGCTAACAGGAGGAATTAACCATGGGCAGCAGCCATCATCATCATCATCACGGCAGCGGCCTGGTGCCGCGCGGCAGCGCTGGT"
BBseq2 <- "CTTGGGCCCGAACAAAAACTCATCTCAGAAGAGGATCTGAATAGCGCCGTCGACCATCATCATCATCATCATTGAGTTTAAACGGACTCCAGCTTGGCTGTTTTGGCGGATGAGAGAAGATTTTCAGCCTGATACAGATTAAATCAGAACGCAGAAGCGGTCTGATAAAACAGAATTTGCCTGGCGGCAGTAGCGCGGTGGTCCCACCTGACCCCATGCCGAACTCAGAAGTGAAACGCCGTAGCGCCGATGGTAGTGTGGGGTGTCCCCATGCGAGAGTAGGGAACTGCCAGGCATCAAATAAAACGAAAGGCTCAGTCGAAAGACTGGGCCTTTCGTTTTATCTGTTGTTTGTCGGTGAACGCTCTCCTGAGTAGGACAAATCCGCCGGGAGCGGATTTGAACGTTGCGAAGCAACGGCCCGGAGGGTGGCGGGCAGGACGCCCGCCATAAACTGCCAGGCATCAAATTAAGCAGAAGGCCATCCTGACGGATGGCCTTTTTGCGTTTCTACAAACTCTTTTTGTTTATTTTTCTAAATACATTCAAATATGTATCCGCTCATGAGACAATAACCCTGATAAATGCTTCAATAATATTGAAAAAGGAAGAGTATGAGTATTCAACATTTCCGTGTCGCCCTTATTCCCTTTTTTGCGGCATTTTGCCTTCCTGTTTTTGCTCACCCAGAAACGCTGGTGAAAGTAAAAGATGCTGAAGATCAGTTGGGTGCACGAGTGGGTTACATCGAACTGGATCTCAACAGCGGTAAGATCCTTGAGAGTTTTCGCCCCGAAGAACGTTTTCCAATGATGAGCACTTTTAAAGTTCTGCTATGTGGCGCGGTATTATCCCGTGTTGACGCCGGGCAAGAGCAACTCGGTCGCCGCATACACTATTCTCAGAATGACTTGGTTGAGTACTCACCAGTCACAGAAAAGCATCTTACGGATGGCATGACAGTAAGAGAATTATGCAGTGCTGCCATAACCATGAGTGATAACACTGCGGCCAACTTACTTCTGACAACGATCGGAGGACCGAAGGAGCTAACCGCTTTTTTGCACAACATGGGGGATCATGTAACTCGCCTTGATCGTTGGGAACCGGAGCTGAATGAAGCCATACCAAACGACGAGCGTGACACCACGATGCCTGTAGCAATGGCAACAACGTTGCGCAAACTATTAACTGGCGAACTACTTACTCTAGCTTCCCGGCAACAATTAATAGACTGGATGGAGGCGGATAAAGTTGCAGGACCACTTCTGCGCTCGGCCCTTCCGGCTGGCTGGTTTATTGCTGATAAATCTGGAGCCGGTGAGCGTGGGAGTCGCGGTATCATTGCAGCACTGGGGCCAGATGGTAAGCCCTCCCGTATCGTAGTTATCTACACGACGGGGAGTCAGGCAACTATGGATGAACGAAATAGACAGATCGCTGAGATAGGTGCCTCACTGATTAAGCATTGGTAACTGTCAGACCAAGTTTACTCATATATACTTTAGATTGATTTAAAACTTCATTTTTAATTTAAAAGGATCTAGGTGAAGATCCTTTTTGATAATCTCATGACCAAAATCCCTTAACGTGAGTTTTCGTTCCACTGAGCGTCAGACCCCGTAGAAAAGATCAAAGGATCTTCTTGAGATCCTTTTTTTCTGCGCGTAATCTGCTGCTTGCAAACAAAAAAACCACCGCTACCAGCGGTGGTTTGTTTGCCGGATCAAGAGCTACCAACTCTTTTTCCGAAGGTAACTGGCTTCAGCAGAGCGCAGATACCAAATACTGTCCTTCTAGTGTAGCCGTAGTTAGGCCACCACTTCAAGAACTCTGTAGCACCGCCTACATACCTCGCTCTGCTAATCCTGTTACCAGTGGCTGCTGCCAGTGGCGATAAGTCGTGTCTTACCGGGTTGGACTCAAGACGATAGTTACCGGATAAGGCGCAGCGGTCGGGCTGAACGGGGGGTTCGTGCACACAGCCCAGCTTGGAGCGAACGACCTACACCGAACTGAGATACCTACAGCGTGAGCTATGAGAAAGCGCCACGCTTCCCGAAGGGAGAAAGGCGGACAGGTATCCGGTAAGCGGCAGGGTCGGAACAGGAGAGCGCACGAGGGAGCTTCCAGGGGGAAACGCCTGGTATCTTTATAGTCCTGTCGGGTTTCGCCACCTCTGACTTGAGCGTCGATTTTTGTGATGCTCGTCAGGGGGGCGGAGCCTATGGAAAAACGCCAGCAACGCGGCCTTTTTACGGTTCCTGGCCTTTTGCTGGCCTTTTGCTCACATGTTCTTTCCTGCGTTATCCCCTGATTCTGTGGATAACCGTATTACCGCCTTTGAGTGAGCTGATACCGCTCGCCGCAGCCGAACGACCGAGCGCAGCGAGTCAGTGAGCGAGGAAGCGGAAGAGCGCCTGATGCGGTATTTTCTCCTTACGCATCTGTGCGGTATTTCACACCGCATATCGTGCACTCTCAGTACAATCTGCTCTGATGCCGCATAGTTAAGCCAGTATACACTCCGCTATCGCTACGTGACTGGGTCATGGCTGCGCCCCGACACCCGCCAACACCCGCTGACGCGCCCTGACGGGCTTGTCTGCTCCCGGCATCCGCTTACAGACAAGCTGTGACCGTCTCCGGGAGCTGCATGTGTCAGAGGTTTTCACCGTCATCACCGAAACGCGCGAGGCAGCAGATCAATTCGCGCGCGAAGGCGAAGCGGCATGCATAATGTGCCTGTCAAATGGACGAAGCAGGGATTCTGCAAACCCTATGCTACTCCGTCAAGCCGTCAATTGTCTGATTCGTTACCAATTATGACAACTTGACGGCTACATCATTCACTTTTTCTTCACAACCGGCACGGAACTCGCTCGGGCTGGCCCCGGTGCATTTTTTAAATACCCGCGAGAAATAGAGTTGATCGTCAAAACCAACATTGCGACCGACGGTGGCGATAGGCATCCGGGTGGTGCTCAAAAGCAGCTTCGCCTGGCTGATACGTTGGTCCTCGCGCCAGCTTAAGACGCTAATCCCTAACTGCTGGCGGAAAAGATGTGACAGACGCGACGGCGACAAGCAAACATGCTGTGCGACGCTGGCGATATCAAAATTGCTGTCTGCCAGGTGATCGCTGATGTACTGACAAGCCTCGCGTACCCGATTATCCATCGGTGGATGGAGCGACTCGTTAATCGCTTCCATGCGCCGCAGTAACAATTGCTCAAGCAGATTTATCGCCAGCAGCTCCGAATAGCGCCCTTCCCCTTGCCCGGCGTTAATGATTTGCCCAAACAGGTCGCTGAAATGCGGCTGGTGCGCTTCATCCGGGCGAAAGAACCCCGTATTGGCAAATATTGACGGCCAGTTAAGCCATTCATGCCAGTAGGCGCGCGGACGAAAGTAAACCCACTGGTGATACCATTCGCGAGCCTCCGGATGACGACCGTAGTGATGAATCTCTCCTGGCGGGAACAGCAAAATATCACCCGGTCGGCAAACAAATTCTCGTCCCTGATTTTTCACCACCCCCTGACCGCGAATGGTGAGATTGAGAATATAACCTTTCATTCCCAGCGGTCGGTCGATAAAAAAATCGAGATAACCGTTGGCCTCAATCGGCGTTAAACCCGCCACCAGATGGGCATTAAACGAGTATCCCGGCAGCAGGGGATCATTTTGCGCTTCAGCCATACTTTTCATACTCCCGCCATTCAGAGAAGAAACCAATTGTCCATATTGCATCAGACATTGCCGTCACTGCGTCTTTTACTGGCTCTTCTCGCTAACCAAACCGGTAACCCCGCTTATTAAAAGCATTCTGTAACAAAGCGGGACCAAAGCCATGACAAAAACGCGTAACAAAAGTGTCTATAATCACGGCAGAAAAGTCCACATTGATTATTTGCACGGCGTCACACTTTGCT"
sumoBB1 <- "ATGCCATAGCATTTTTATCCATAAGATTAGCGGATCCTACCTGACGCTTTTTATCGCAACTCTCTACTGTTTCTCCATACCCGTTTTTTGGGCTAACAGGAGGAATTAACCATGGGCAGCAGCCATCATCATCATCATCACGGCAGCGGCCTGGTGCCGCGCGGCAGCGCTAGCATGTCGGACTCAGAAGTCAATCAAGAAGCTAAGCCAGAGGTCAAGCCAGAAGTCAAGCCTGAGACTCACATCAATTTAAAGGTGTCCGATGGATCTTCAGAGATCTTCTTCAAGATCAAAAAGACCACTCCTTTAAGAAGGCTGATGGAAGCGTTCGCTAAAAGACAGGGTAAGGAAATGGACTCCTTAAGATTCTTGTACGACGGTATTAGAATTCAAGCTGATCAGACCCCTGAAGATTTGGACATGGAGGATAACGATATTATTGAGGCTCACAGAGAACAGATTGGTGGT"
sumoBB2 <-"GGCCCGAACAAAAACTCATCTCAGAAGAGGATCTGAATAGCGCCGTCGACCATCATCATCATCATCATTGAGTTTAAACGGACTCCAGCTTGGCTGTTTTGGCGGATGAGAGAAGATTTTCAGCCTGATACAGATTAAATCAGAACGCAGAAGCGGTCTGATAAAACAGAATTTGCCTGGCGGCAGTAGCGCGGTGGTCCCACCTGACCCCATGCCGAACTCAGAAGTGAAACGCCGTAGCGCCGATGGTAGTGTGGGGTGTCCCCATGCGAGAGTAGGGAACTGCCAGGCATCAAATAAAACGAAAGGCTCAGTCGAAAGACTGGGCCTTTCGTTTTATCTGTTGTTTGTCGGTGAACGCTCTCCTGAGTAGGACAAATCCGCCGGGAGCGGATTTGAACGTTGCGAAGCAACGGCCCGGAGGGTGGCGGGCAGGACGCCCGCCATAAACTGCCAGGCATCAAATTAAGCAGAAGGCCATCCTGACGGATGGCCTTTTTGCGTTTCTACAAACTCTTTTTGTTTATTTTTCTAAATACATTCAAATATGTATCCGCTCATGAGACAATAACCCTGATAAATGCTTCAATAATATTGAAAAAGGAAGAGTATGAGTATTCAACATTTCCGTGTCGCCCTTATTCCCTTTTTTGCGGCATTTTGCCTTCCTGTTTTTGCTCACCCAGAAACGCTGGTGAAAGTAAAAGATGCTGAAGATCAGTTGGGTGCACGAGTGGGTTACATCGAACTGGATCTCAACAGCGGTAAGATCCTTGAGAGTTTTCGCCCCGAAGAACGTTTTCCAATGATGAGCACTTTTAAAGTTCTGCTATGTGGCGCGGTATTATCCCGTGTTGACGCCGGGCAAGAGCAACTCGGTCGCCGCATACACTATTCTCAGAATGACTTGGTTGAGTACTCACCAGTCACAGAAAAGCATCTTACGGATGGCATGACAGTAAGAGAATTATGCAGTGCTGCCATAACCATGAGTGATAACACTGCGGCCAACTTACTTCTGACAACGATCGGAGGACCGAAGGAGCTAACCGCTTTTTTGCACAACATGGGGGATCATGTAACTCGCCTTGATCGTTGGGAACCGGAGCTGAATGAAGCCATACCAAACGACGAGCGTGACACCACGATGCCTGTAGCAATGGCAACAACGTTGCGCAAACTATTAACTGGCGAACTACTTACTCTAGCTTCCCGGCAACAATTAATAGACTGGATGGAGGCGGATAAAGTTGCAGGACCACTTCTGCGCTCGGCCCTTCCGGCTGGCTGGTTTATTGCTGATAAATCTGGAGCCGGTGAGCGTGGGAGTCGCGGTATCATTGCAGCACTGGGGCCAGATGGTAAGCCCTCCCGTATCGTAGTTATCTACACGACGGGGAGTCAGGCAACTATGGATGAACGAAATAGACAGATCGCTGAGATAGGTGCCTCACTGATTAAGCATTGGTAACTGTCAGACCAAGTTTACTCATATATACTTTAGATTGATTTAAAACTTCATTTTTAATTTAAAAGGATCTAGGTGAAGATCCTTTTTGATAATCTCATGACCAAAATCCCTTAACGTGAGTTTTCGTTCCACTGAGCGTCAGACCCCGTAGAAAAGATCAAAGGATCTTCTTGAGATCCTTTTTTTCTGCGCGTAATCTGCTGCTTGCAAACAAAAAAACCACCGCTACCAGCGGTGGTTTGTTTGCCGGATCAAGAGCTACCAACTCTTTTTCCGAAGGTAACTGGCTTCAGCAGAGCGCAGATACCAAATACTGTCCTTCTAGTGTAGCCGTAGTTAGGCCACCACTTCAAGAACTCTGTAGCACCGCCTACATACCTCGCTCTGCTAATCCTGTTACCAGTGGCTGCTGCCAGTGGCGATAAGTCGTGTCTTACCGGGTTGGACTCAAGACGATAGTTACCGGATAAGGCGCAGCGGTCGGGCTGAACGGGGGGTTCGTGCACACAGCCCAGCTTGGAGCGAACGACCTACACCGAACTGAGATACCTACAGCGTGAGCTATGAGAAAGCGCCACGCTTCCCGAAGGGAGAAAGGCGGACAGGTATCCGGTAAGCGGCAGGGTCGGAACAGGAGAGCGCACGAGGGAGCTTCCAGGGGGAAACGCCTGGTATCTTTATAGTCCTGTCGGGTTTCGCCACCTCTGACTTGAGCGTCGATTTTTGTGATGCTCGTCAGGGGGGCGGAGCCTATGGAAAAACGCCAGCAACGCGGCCTTTTTACGGTTCCTGGCCTTTTGCTGGCCTTTTGCTCACATGTTCTTTCCTGCGTTATCCCCTGATTCTGTGGATAACCGTATTACCGCCTTTGAGTGAGCTGATACCGCTCGCCGCAGCCGAACGACCGAGCGCAGCGAGTCAGTGAGCGAGGAAGCGGAAGAGCGCCTGATGCGGTATTTTCTCCTTACGCATCTGTGCGGTATTTCACACCGCATATCGTGCACTCTCAGTACAATCTGCTCTGATGCCGCATAGTTAAGCCAGTATACACTCCGCTATCGCTACGTGACTGGGTCATGGCTGCGCCCCGACACCCGCCAACACCCGCTGACGCGCCCTGACGGGCTTGTCTGCTCCCGGCATCCGCTTACAGACAAGCTGTGACCGTCTCCGGGAGCTGCATGTGTCAGAGGTTTTCACCGTCATCACCGAAACGCGCGAGGCAGCAGATCAATTCGCGCGCGAAGGCGAAGCGGCATGCATAATGTGCCTGTCAAATGGACGAAGCAGGGATTCTGCAAACCCTATGCTACTCCGTCAAGCCGTCAATTGTCTGATTCGTTACCAATTATGACAACTTGACGGCTACATCATTCACTTTTTCTTCACAACCGGCACGGAACTCGCTCGGGCTGGCCCCGGTGCATTTTTTAAATACCCGCGAGAAATAGAGTTGATCGTCAAAACCAACATTGCGACCGACGGTGGCGATAGGCATCCGGGTGGTGCTCAAAAGCAGCTTCGCCTGGCTGATACGTTGGTCCTCGCGCCAGCTTAAGACGCTAATCCCTAACTGCTGGCGGAAAAGATGTGACAGACGCGACGGCGACAAGCAAACATGCTGTGCGACGCTGGCGATATCAAAATTGCTGTCTGCCAGGTGATCGCTGATGTACTGACAAGCCTCGCGTACCCGATTATCCATCGGTGGATGGAGCGACTCGTTAATCGCTTCCATGCGCCGCAGTAACAATTGCTCAAGCAGATTTATCGCCAGCAGCTCCGAATAGCGCCCTTCCCCTTGCCCGGCGTTAATGATTTGCCCAAACAGGTCGCTGAAATGCGGCTGGTGCGCTTCATCCGGGCGAAAGAACCCCGTATTGGCAAATATTGACGGCCAGTTAAGCCATTCATGCCAGTAGGCGCGCGGACGAAAGTAAACCCACTGGTGATACCATTCGCGAGCCTCCGGATGACGACCGTAGTGATGAATCTCTCCTGGCGGGAACAGCAAAATATCACCCGGTCGGCAAACAAATTCTCGTCCCTGATTTTTCACCACCCCCTGACCGCGAATGGTGAGATTGAGAATATAACCTTTCATTCCCAGCGGTCGGTCGATAAAAAAATCGAGATAACCGTTGGCCTCAATCGGCGTTAAACCCGCCACCAGATGGGCATTAAACGAGTATCCCGGCAGCAGGGGATCATTTTGCGCTTCAGCCATACTTTTCATACTCCCGCCATTCAGAGAAGAAACCAATTGTCCATATTGCATCAGACATTGCCGTCACTGCGTCTTTTACTGGCTCTTCTCGCTAACCAAACCGGTAACCCCGCTTATTAAAAGCATTCTGTAACAAAGCGGGACCAAAGCCATGACAAAAACGCGTAACAAAAGTGTCTATAATCACGGCAGAAAAGTCCACATTGATTATTTGCACGGCGTCACACTTTGCT"

# server <- function(input, output, session) {
#   
#   processed_input <- reactive({
#     #Create 2 data frames containing the positions where bsaI1 site "GGTCTC" and bsaI2 site "GAGACC" are found in the given input DNA sequence.
#     #[[1]] is to make a data frame instead of a matrix
#     # to call the input use the id given in the UI after the $ sign.
#     
#      bsaI1.df <- str_locate_all(input$sequence, "GGTCTC")[[1]] %>% as.data.frame() # output of str_locate is matrix, need to convert to df
#      bsaI2.df <- str_locate_all(input$sequence, "GAGACC")[[1]] %>% as.data.frame()
#      
#      if (nrow(bsaI1.df) == 0 && nrow(bsaI2.df) == 0) {
#        output$bsaI_search <- renderText("No BsaI sites were found")
#        return(NULL)  # Return NULL when no BsaI sites are found
#      } else if (nrow(bsaI1.df) > 0 && nrow(bsaI2.df) == 0) {
#        output$bsaI_search <- renderText("BsaI1 sites were found")
#        bsaI1.df$GGTCTC <- TRUE
#        bsaI1.df$GAGACC <- FALSE
#        bsaI1.df$suggested_sequence <-
#          sub("GGT", "GGC", input$sequence)  # Create the suggested sequence for BsaI1
#        return(bsaI1.df)  # Return the data frame for BsaI1 sites when only BsaI1 sites are found
#        
#      } else if (nrow(bsaI1.df) == 0 && nrow(bsaI2.df) > 0) {
#        output$bsaI_search <- renderText("BsaI2 sites were found")
#        bsaI2.df$GGTCTC <- FALSE
#        bsaI2.df$GAGACC <- TRUE
#        bsaI2.df$suggested_sequence <-
#          sub("GAGACC", "GAGACC", input$sequence)  # Create the suggested sequence for BsaI2
#        return(bsaI2.df)  # Return the data frame for BsaI2 sites when only BsaI2 sites are found
#        
#      } else {
#        output$bsaI_search <-
#          renderText("Both BsaI1 and BsaI2 sites were found")
#        # Both data frames have BsaI sites, so merge them
#        #Create extra columns to indicate whether fw or rv BsaI sites have been found
#        bsaI1.df$GGTCTC <- TRUE
#        bsaI1.df$GAGACC <- FALSE
#        bsaI2.df$GGTCTC <- FALSE
#        bsaI2.df$GAGACC <- TRUE
#        
#        #Merge both data frames
#        bsaI.df <- rbind(bsaI1.df, bsaI2.df) %>% as.data.frame()
#        
#        #Create an extra column to indicate the position of the BsaI site in the codon.
#        #%% 3 gives you the rest after dividing by 3. When the rest is 1 is in position 1,
#        #when it´s 2 in position 2, and when it´s 0 in position 3.
#        #Substitute 0s by 3s
#        bsaI.df$position <- bsaI.df$start %% 3
#        bsaI.df$position[bsaI.df$position == 0] <- 3
#        
#        # Create suggested sequences for both BsaI1 and BsaI2
#        bsaI.df$suggested_sequence <- ifelse(
#          bsaI.df$position == 1,
#          sub("GGT", "GGC", input$sequence),
#          sub("GAG", "GAA", input$sequence)
#        )
#        
#        return(bsaI.df)  # Return the merged data frame with BsaI sites
#      }
#     ## GGTCTC
#     ## 1: GGT = GGC
#     ## 2: GTC = GTG
#     ## 3: TCT = AGC
#     ## GAGACC
#     ## 1: GAG = GAA
#     ## 2: AGA = CGT
#     ## 3: GAC = GAT
#     
#     seq <- toupper(input$sequence)
#     
# #!!bug!! when the position is 1 (BsaI starts at first base of a codon) it changes the first BsaI site that it finds, whichever it is. When it is in position 3, changes the 3rd BsaI site.
#     
#     df <- rbind(
#       seq %>% str_locate_all(., "GGTCTC") %>% as.data.frame() %>% mutate(dir = 'fw'),
#       seq %>% str_locate_all(., "GAGACC") %>% as.data.frame() %>% mutate(dir = 'rv')
#     ) %>% mutate(cod_pos = ((start + 2) %% 3) + 1) 
#     
#     df$first_cod_to_change <- ifelse(df$dir == 'fw', 
#                                     c('GTC','GGT','TCT')[(df$cod_pos %% 3) + 1], 
#                                     c('AGA', 'GAG', 'GAC')[(df$cod_pos %% 3) + 1])
#     df$change_cod_to <- ifelse(df$dir == 'fw', 
#                                c('GTG','GGC','AGC')[(df$cod_pos %% 3) + 1], 
#                                c('CGT', 'GAA', 'GAT')[(df$cod_pos %% 3) + 1])
#     
#     df[order(df$start),]
#   
#   })
#   
#   # Check length of sequence 
#   length_seq <- nchar(seq)
# 
#   # Number of fragments needed: 1 (0-288), 2 (291-580), 3 (581-870), 4 (871-1160), 5 (1161-1450)
#   if (length_seq <= 288*3) {
#     fragments <- cat(BsaTGGT, seq, BsaSTOPCTTG, sep = "")
# 
#   } else if (length_seq <= 580*3){
#     piece1 <- substr(seq, 1, nchar(seq)/2)
#     fragm1 <- cat(BsaTGGT, piece1, BsaMid1, sep = "")
#     
#     piece2 <- substr(seq, (nchar(seq)/2)+1, nchar(seq))
#     fragm2 <- cat(BsaMid2, piece2, BsaSTOPCTTG, sep = "")
#     
#     fragments <- c(fragm1, fragm2)
#     
#   } else if (length_seq <= 870*3){
#     piece1 <- substr(seq, 1, nchar(seq)/3)
#     fragm1 <- cat(BsaTGGT, piece1, BsaMid1, sep = "")
#     
#     piece2 <- substr(seq, (nchar(seq)/3)+1, nchar(seq)/3*2)
#     fragm2 <- cat(BsaMid2, piece2, BsaMid1, sep = "")
#     
#     piece3 <- substr(seq, (nchar(seq)/3*2)+1, nchar(seq))
#     fragm3 <- cat(BsaMid2, piece3, BsaSTOPCTTG, sep = "")
#     
#     fragments <- c(fragm1, fragm2, fragm3)
#     
#   } else if (length_seq <= 1160*3){
#     piece1 <- substr(seq, 1, nchar(seq)/4)
#     fragm1 <- cat(BsaTGGT, piece1, BsaMid1, sep = "")
#     
#     piece2 <- substr(seq, (nchar(seq)/4)+1, nchar(seq)/4*2)
#     fragm2 <- cat(BsaMid2, piece2, BsaMid1, sep = "")
#     
#     piece3 <- substr(seq, (nchar(seq)/4*2)+1, nchar(seq)/4*3)
#     fragm3 <- cat(BsaMid2, piece3, BsaMid1, sep = "")
#     
#     piece4 <- substr(seq, (nchar(seq)/4*3)+1, nchar(seq))
#     fragm4 <- cat(BsaMid2, piece4, BsaSTOPCTTG, sep = "")
# 
#     fragments <- c(fragm1, fragm2, fragm3, fragm4)
#     
#   } else if (length_seq <= 1450*3){
#     piece1 <- substr(seq, 1, nchar(seq)/5)
#     fragm1 <- cat(BsaTGGT, piece1, BsaMid1, sep = "")
#     
#     piece2 <- substr(seq, (nchar(seq)/5)+1, nchar(seq)/5*2)
#     fragm2 <- cat(BsaMid2, piece2, BsaMid1, sep = "")
#     
#     piece3 <- substr(seq, (nchar(seq)/5*2)+1, nchar(seq)/5*3)
#     fragm3 <- cat(BsaMid2, piece3, BsaMid1, sep = "")
#     
#     piece4 <- substr(seq, (nchar(seq)/5*3)+1, nchar(seq)/5*4)
#     fragm4 <- cat(BsaMid2, piece4, BsaMid1, sep = "")
#     
#     piece5 <- substr(seq, (nchar(seq)/5*4)+1, nchar(seq))
#     fragm5 <- cat(BsaMid2, piece5, BsaSTOPCTTG, sep = "")
#     
#     fragments <- c(fragm1, fragm2, fragm3, fragm4, fragm5)
#     
#   } else {
#   #this should be a text output 
#     return("Sequence too long")
#   }
# 
#   
#   output$table <- renderDT({
#     if (!is.null(processed_input())) {
#       datatable(processed_input(), options = list(dom = 't'))  # Display the data table
#     } else {
#       data.frame()  # Return an empty data frame when no BsaI sites are found
#     }
#   })
# }

# function to make a random DNA sequence of length n, for testing
example_seq <- function(n) {
  sample(c('A', 'C', 'T', 'G'), n, replace = TRUE) %>% paste0(collapse = '')
}

# func. to find bsai sites in input seq, returns a dataframe
bsai_locate <- function(seq) {
  df <- rbind(
    seq %>% str_locate_all(., "GGTCTC") %>% as.data.frame() %>% mutate(dir = 'fw'),
    seq %>% str_locate_all(., "GAGACC") %>% as.data.frame() %>% mutate(dir = 'rv')
  ) %>% mutate(cod_pos = ((start + 2) %%3) + 1)
  df[order(df$start),] # return in order of where site was encountered
}

# func. to determine how many fragments are required given a sequence and a max. frag. length
calc_fragments <- function(seq, max_len) {
  ceiling(nchar(seq) / max_len) # ceiling() rounds up to next integer
}

# function to calculate the break points in a sequence, given max. frag. length
calc_break_points <- function(seq, max_len) {
  (calc_fragments(seq, max_len) -1) * 2
}

# func. to create n_chunks sequence fragments, returns vector of strings
seq_chunks <- function(seq, n_chunks) {
  if (n_chunks == 1) { return(seq) } # if only 1 chunk is requested, return input and stop
  seq <- str_split(seq, '')[[1]] # create vector from string
  split(seq, cut(seq_along(seq), n_chunks, labels = FALSE)) # returns list where each item is vector chunk
}

# func. to create df with seq. fragments, given sequence and max. frag. length
split_seq_in_chunks <- function(seq, max_len) {
  if (seq == '' || !is.numeric(max_len) || is.na(max_len)) { return(data.frame()) } 
  chunks <- seq_chunks(seq = seq, n_chunks = calc_fragments(seq, max_len)) %>% lapply(., function(x) paste(x, collapse = '')) 
  data.frame(length = lapply(chunks, function(x) str_length(x)) %>% unlist(), 
             fragments = unlist(chunks)) # convert list into data frame, can add more info (columns) about fragments
} 

# calculate new sequence here, can use something like substr(seq, start, stop) <- 'replacem_codon'
# calc_new_seq <- function(seq, bsai_info) {
#   
#   new_seq <- str_replace(seq, )
#   new_seq
# }


server <- function(input, output, session) {
  
  # for testing; create random sequences of length specified in input$ex_len
  observeEvent(input$ex_len, {
    if (str_detect(input$ex_len, '^[0-9]+$')) {
      updateTextInput(session = getDefaultReactiveDomain(), 
                      inputId = 'sequence',
                      value = example_seq(n = as.numeric(input$ex_len)))
    }
  }, ignoreInit = TRUE)
  
  # process the sequence: upper case, detect bsai sites, find position within codon, suggest swapped codon
  processed_input <- reactive({
    df <- bsai_locate(seq = toupper(input$sequence))
    df$first_cod_to_change <- ifelse(df$dir == 'fw', 
                                    c('GTC', 'GGT', 'TCT')[(df$cod_pos %% 3) + 1], 
                                    c('AGA', 'GAG', 'GAC')[(df$cod_pos %% 3) + 1])
    df$change_cod_to <- ifelse(df$dir == 'fw', 
                                    c('GTG', 'GGC', 'TCC')[(df$cod_pos %% 3) + 1], 
                                    c('AGG', 'GAA', 'GAT')[(df$cod_pos %% 3) + 1])
    
    df  
  })
  
  # output table for bsai sites
  output$bsai_table <- renderDT({
    # something like this for filling a new text input field with the new sequence
    # updateTextInput(session = getDefaultReactiveDomain(), 
    #                 inputId = 'sequence',
    #                 value = calc_new_seq(seq = input$sequence, bsai_info = processed_input()))
    datatable(processed_input(), options = list(dom = 't'))  # option removes (here) pointless search field
  })
  
  # output table for fragments
  output$frag_table <- renderDT({
    split_seq_in_chunks(seq = input$sequence, max_len = as.numeric(input$frag_len))
  })
  
  # return some info about framgents as text
  output$total_len <- renderText({
    mid_sites_to_add <- calc_break_points(seq = input$sequence, max_len = as.numeric(input$frag_len))
    total_len <- nchar(input$sequence) + nchar(BsaTGGT) + nchar(BsaSTOPCTTG) + (mid_sites_to_add * nchar(BsaMid1))
    HTML(paste0("Input sequence length: &nbsp", as.character(nchar(input$sequence)), "<br>", 
                "Number of fragments &nbsp: &nbsp", as.character(mid_sites_to_add), "<br>",
                "Final number of bases: &nbsp", as.character(total_len)))
  })
}

